/**
 * Firebase service for packing list management
 * Structure: /users/{userId}/trips/{tripId}/packingList/{itemId}
 */

import {
  collection,
  doc,
  setDoc,
  getDoc,
  getDocs,
  updateDoc,
  deleteDoc,
  query,
  orderBy,
  writeBatch,
} from "firebase/firestore";
import { db } from "../config/firebase";
import { PackingItem, CampingStyle } from "../types/camping";

/**
 * Get all packing items for a trip
 */
export async function getPackingList(userId: string, tripId: string): Promise<PackingItem[]> {
  try {
    const packingRef = collection(db, "users", userId, "trips", tripId, "packingList");
    const q = query(packingRef, orderBy("category"));
    const snapshot = await getDocs(q);

    return snapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    })) as PackingItem[];
  } catch (error: any) {
    // Don't log permissions errors as errors - they're expected and handled by fallback
    if (error?.code === 'permission-denied' || error?.message?.includes('Missing or insufficient permissions')) {
      // Silently throw to trigger fallback
      throw error;
    }
    console.error("Error fetching packing list:", error);
    throw error;
  }
}

/**
 * Add a packing item
 */
export async function addPackingItem(
  userId: string,
  tripId: string,
  item: Omit<PackingItem, "id">
): Promise<string> {
  try {
    const packingRef = collection(db, "users", userId, "trips", tripId, "packingList");
    const newItemRef = doc(packingRef);

    await setDoc(newItemRef, item);
    return newItemRef.id;
  } catch (error) {
    console.error("Error adding packing item:", error);
    throw error;
  }
}

/**
 * Update a packing item
 */
export async function updatePackingItem(
  userId: string,
  tripId: string,
  itemId: string,
  updates: Partial<PackingItem>
): Promise<void> {
  try {
    const itemRef = doc(db, "users", userId, "trips", tripId, "packingList", itemId);
    await updateDoc(itemRef, updates);
  } catch (error: any) {
    // Don't log permissions errors as errors - they're expected and handled by fallback
    if (error?.code === 'permission-denied' || error?.message?.includes('Missing or insufficient permissions')) {
      throw error;
    }
    console.error("Error updating packing item:", error);
    throw error;
  }
}

/**
 * Toggle packed status
 */
export async function togglePackingItem(
  userId: string,
  tripId: string,
  itemId: string,
  isPacked: boolean
): Promise<void> {
  return updatePackingItem(userId, tripId, itemId, { isPacked });
}

/**
 * Delete a packing item
 */
export async function deletePackingItem(
  userId: string,
  tripId: string,
  itemId: string
): Promise<void> {
  try {
    const itemRef = doc(db, "users", userId, "trips", tripId, "packingList", itemId);
    await deleteDoc(itemRef);
  } catch (error) {
    console.error("Error deleting packing item:", error);
    throw error;
  }
}

/**
 * Generate packing list from template
 * This will be called when a trip is created or regenerated
 */
export async function generatePackingListFromTemplate(
  userId: string,
  tripId: string,
  campStyle: CampingStyle,
  conditions?: {
    isCold?: boolean;
    isRainy?: boolean;
    isHot?: boolean;
  }
): Promise<void> {
  try {
    // Get the template for this camping style
    const templateRef = doc(db, "campTemplates", campStyle);
    const templateSnap = await getDoc(templateRef);

    if (!templateSnap.exists()) {
      console.warn("No template found for camping style:", campStyle);
      return;
    }

    const template = templateSnap.data();
    const packingRef = collection(db, "users", userId, "trips", tripId, "packingList");

    // Start a batch write
    const batch = writeBatch(db);

    // Add base items
    if (template.baseItems) {
      template.baseItems.forEach((item: Omit<PackingItem, "id" | "isPacked">) => {
        const itemRef = doc(packingRef);
        batch.set(itemRef, {
          ...item,
          isPacked: false,
          isAutoGenerated: true,
        });
      });
    }

    // Add seasonal modifiers
    if (conditions?.isCold && template.seasonalModifiers?.cold) {
      template.seasonalModifiers.cold.forEach((item: Omit<PackingItem, "id" | "isPacked">) => {
        const itemRef = doc(packingRef);
        batch.set(itemRef, {
          ...item,
          isPacked: false,
          isAutoGenerated: true,
        });
      });
    }

    if (conditions?.isRainy && template.seasonalModifiers?.rainy) {
      template.seasonalModifiers.rainy.forEach((item: Omit<PackingItem, "id" | "isPacked">) => {
        const itemRef = doc(packingRef);
        batch.set(itemRef, {
          ...item,
          isPacked: false,
          isAutoGenerated: true,
        });
      });
    }

    if (conditions?.isHot && template.seasonalModifiers?.hot) {
      template.seasonalModifiers.hot.forEach((item: Omit<PackingItem, "id" | "isPacked">) => {
        const itemRef = doc(packingRef);
        batch.set(itemRef, {
          ...item,
          isPacked: false,
          isAutoGenerated: true,
        });
      });
    }

    await batch.commit();
  } catch (error) {
    console.error("Error generating packing list:", error);
    throw error;
  }
}

/**
 * Delete all auto-generated items (for regeneration)
 */
export async function deleteAutoGeneratedItems(
  userId: string,
  tripId: string
): Promise<void> {
  try {
    const packingRef = collection(db, "users", userId, "trips", tripId, "packingList");
    const snapshot = await getDocs(packingRef);

    const batch = writeBatch(db);
    snapshot.docs.forEach((doc) => {
      const data = doc.data();
      if (data.isAutoGenerated) {
        batch.delete(doc.ref);
      }
    });

    await batch.commit();
  } catch (error) {
    console.error("Error deleting auto-generated items:", error);
    throw error;
  }
}
